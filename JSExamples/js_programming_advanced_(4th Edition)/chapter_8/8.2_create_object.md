通过Object构造函数和对象字面量可以方便的创建对象。但这些方式也有明显不足：创建具
有同样属性和方法的多个对象需要重复编写很多代码。

## 概述
ES6中的类是封装构造函数+原型继承的语法糖。

## 工厂模式
能解决创建多个相似对象的问题，但`没有解决对象标识的问题（即新创建的对象是什么类型）`。

```js
function createPerson(name, age, job) {
    var o = new Object()
    o.name = name
    o.age = age
    o.job = job
    o.sayName = function () {
        console.log(this.name)
    }

    return o
}

let person1 = createPerson('Nicholas', 29, 'Software Engineer')
let person2 = createPerson('Greg', 27, 'Doctor')

person1.sayName()
```

## 构造函数模式
构造函数用于创建特定类型的对象。
构造函数可以是原生构造函数，如Object、Array等。也可以是自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。

```js
/*
* 构造函数创建对象
*/
function Person(name, age, job) {
    this.name = name
    this.age = age
    this.job = job
    this.sayName = function () {
        console.log(this.name)
    }
}

let person3 = new Person('Nicholas', 29, 'Software Engineer')
let person4 = new Person('Greg', 27, 'Doctor')

person3.sayName()
```

* 按照惯例，构造函数名称的首字母大写，非构造函数名称的首字母小写。
* 构造函数创建对象时，要用`new`操作符。对象属性和方法定义在构造函数内部，即构造函数内部定义的属性和方法是实例属性和方法。
* 构造函数创建对象时，`this`指向新创建的对象。

赋值给变量的函数表达式也可以表示构造函数。

```js
/*
* 函数表达式也可以表示构造函数
*/
let Person = function(name, age, job){
    this.name = name
    this.age = age
    this.job = job
    this.sayName = function () {
        console.log(this.name)
    }
}

let person3 = new Person('Nicholas', 29, 'Software Engineer')
let person4 = new Person('Greg', 27, 'Doctor')
person3.sayName()
```

### 构造函数也是函数
构造函数与普通函数的唯一区别就是它的调用方式不同。构造函数通常使用new操作符来调用，如果不使用new操作符，而是直接调用，就是一个普通函数，则适用普通函数规则。

### 构造函数的问题
构造函数的主要问题是：其定义的方法不能共用Function实例。
为了解决这个问题，可以把方法定义在构造函数外部，但这又会搞乱全局作用域，同时使自定义类型引用的代码不能聚集在一起。

## 原型模式
每个函数都会创建一个`prototype`属性，这个属性是一个对象，包含应该由特定引用类型的实例
共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处
是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以
直接赋值给它们的原型。

```js
function Student() {}
// let Student = function () {} // 函数表达式也可以表示构造函数

Student.prototype.name = 'Nicholas'
Student.prototype.age = 29
Student.prototype.job = 'Software Engineer'
Student.prototype.sayName = function () {
    console.log(this.name)
}

let student1 = new Student()
let student2 = new Student()

student1.sayName()
```

### 理解原型
构造函数原型：自定义构造函数时，会为构造函数创建一个`prototype`属性（指向原型对象）。原型对象自动获得一个`constructor`属性，这个属性指向与之关联的构造函数。
构造函数创建的每个对象实例：都包含一个`__proto__`属性，指向构造函数的`prototype`属性。

实例与构造函数原型之间有直接的联系，实例与构造函数之间没有直接联系。

* 通过isPrototypeOf()方法判断实例与构造函数原型之间是否有直接联系，如：

```js
console.log(Student.prototype.isPrototypeOf(student1)) // true
```

* Object.getPrototypeOf(object)，返回对象的原型，如：

```js
console.log(Object.getPrototypeOf(student1))
console.log(Object.getPrototypeOf(student1) === Student.prototype) // true
```

* Object.setPrototypeOf(object, prototype)，修改对象原型，向实例的私有特性[[Prototype]]写入一个新值，如：

```js
// 修改对象原型可能导致性能下降
Object.setPrototypeOf(student1, {
    numLegs: 2
})
```

* Object.create(prototype)，创建一个新对象，参数为对象原型，返回新对象，如：

```js
let biped = {
    numLegs: 2
};
let person = Object.create(biped);

person.name = 'Matt';
console.log(person.name); // Matt
console.log(person.numLegs); // 2
console.log(Object.getPrototypeOf(person) === biped); // true
```

### 原型层级
在通过对象访问属性时，会先在实例上查找，找不到再查找原型对象。

* 可以通过对象实例访问原型对象的属性，但是不能通过对象实例修改原型对象属性的值。如果在对象实例上添加了同名属性，则实例属性会`屏蔽`原型对象属性。使用`delete`操作符可以删除实例属性，从而恢复访问原型对象属性。
* obj.hasOwnProperty(propertyName)，判断对象实例是否有该属性，如：

```js
console.log(person1.hasOwnProperty('name'))
console.log(person1.hasOwnProperty('numLegs'))
```

* Object.getOwnPropertyDescriptor(obj, propertyName), 获取对象实例属性的描述符，如：

```js
console.log(Object.getOwnPropertyDescriptor(person1, 'name'))

// {value: 'Nicholas', writable: true, enumerable: true, configurable: true}
```

### 原型和in操作符
有两种方式使用in操作符：单独使用和在for...in循环中使用。

* 单独使用in操作符时，会在可以通过对象访问指定属性时返回true，无论属性是实例属性还是原型对象属性。
```js
function Person() {}
Person.prototype.name = 'Nicholas'

let person1 = new Person()
console.log(person1.hasOwnProperty('name')) // false
console.log('name' in person1) // true

/*
* 检测属性是否是原型对象属性
*/
function hasPrototypeProperty(object, propertyName) {
    return !object.hasOwnProperty(propertyName) && （propertyName in object）
}
```

* 在`for-in`循环中使用`in`操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。

* Object.keys(object)，获取`对象可枚举实例属性`，返回属性名称数组，如：

```js
console.log(Object.keys(person1)) // ['name']
console.log(Object.keys(person1.__proto__)) // ['name', 'age', 'job', 'sayName']
```

* Object.getOwnPropertyNames(object)，获取对象所有实例属性（不管能不能枚举），返回属性名称数组。
* Object.getOwnPropertySymbols(object)，获取对象所有实例符号属性（不管能不能枚举），返回符号属性名称数组。
* Object.assign(target, source)，将源对象中的所有可枚举属性复制到目标对象，返回目标对象。

### 属性枚举顺序
`for-in循环和Object.keys()`的枚举顺序是不确定的，取决于JavaScript引擎，可能因浏览器而异。
`Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和Object.assign()`
的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中
定义的键以它们逗号分隔的顺序插入。

## 对象迭代

* Object.keys(object)，获取`对象可枚举实例属性`，返回属性名称数组。
* Object.values(object)，返回对象值的数组（忽略符号属性）。
* Object.entries(object)，返回对象键值对数组（忽略符号属性）。

### 其他原型语法
为了从`视觉`上更好封装原型功能，可以用一个包含属性和方法的对象字面量来重写原型。

```js
function Person() {}
Person.prototype = {
    name: 'Nicholas',
    age: 29,
    job: 'Software Engineer',
    sayName() {
        console.log(this.name)
    }
}

let person1 = new Person()
person1.sayName()

console.log(person1.constructor === Person) // false
console.log(Person.prototype.isPrototypeOf(person1)) // true
```

上面的代码会将`Person.prototype`对象的`constructor`属性会指向新对象，而不是`Person`。可以向下面这样解决：

```js
Person.prototype = {
    constructor: Person,
    name: 'Nicholas',
    age: 29,
    job: 'Software Engineer',
    sayName() {
        console.log(this.name)
    }
}
```

但是这样处理，又会导致`Person.prototype`对象的`constructor`属性成为可枚举的属性，从而导致`for-in`循环返回`constructor`属性。为了避免这种情况，可以使用`Object.defineProperty()`方法来定义`constructor`属性。

```js
function Person() {}

Person.prototype = {
    name: 'Nicholas',
    age: 29,
    job: 'Software Engineer',
    sayName() {
        console.log(this.name)
    }
}

Object.defineProperty(Person.prototype, 'constructor', {
    enumerable: false,
    value: Person
})
```

### 原型的动态性



### 原生对象原型


### 原型的问题


