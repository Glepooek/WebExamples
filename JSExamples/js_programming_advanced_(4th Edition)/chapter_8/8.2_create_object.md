通过Object构造函数和对象字面量可以方便的创建对象。但这些方式也有明显不足：创建具
有同样属性和方法的多个对象需要重复编写很多代码。

## 概述
ES6中的类是封装构造函数+原型继承的语法糖。

## 工厂模式
能解决创建多个相似对象的问题，但`没有解决对象标识的问题（即新创建的对象是什么类型）`。

```js
function createPerson(name, age, job) {
    var o = new Object()
    o.name = name
    o.age = age
    o.job = job
    o.sayName = function () {
        console.log(this.name)
    }

    return o
}

let person1 = createPerson('Nicholas', 29, 'Software Engineer')
let person2 = createPerson('Greg', 27, 'Doctor')

person1.sayName()
```

## 构造函数模式
构造函数用于创建特定类型的对象。
构造函数可以是原生构造函数，如Object、Array等。也可以是自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。

```js
/*
* 构造函数创建对象
*/
function Person(name, age, job) {
    this.name = name
    this.age = age
    this.job = job
    this.sayName = function () {
        console.log(this.name)
    }
}

let person3 = new Person('Nicholas', 29, 'Software Engineer')
let person4 = new Person('Greg', 27, 'Doctor')

person3.sayName()
```

* 按照惯例，构造函数名称的首字母大写，非构造函数名称的首字母小写。
* 构造函数创建对象时，要用`new`操作符。对象属性和方法定义在构造函数内部，即构造函数内部定义的属性和方法是实例属性和方法。
* 构造函数创建对象时，`this`指向新创建的对象。

赋值给变量的函数表达式也可以表示构造函数。

```js
/*
* 函数表达式也可以表示构造函数
*/
let Person = function(name, age, job){
    this.name = name
    this.age = age
    this.job = job
    this.sayName = function () {
        console.log(this.name)
    }
}

let person3 = new Person('Nicholas', 29, 'Software Engineer')
let person4 = new Person('Greg', 27, 'Doctor')
person3.sayName()
```

### 构造函数也是函数
构造函数与普通函数的唯一区别就是它的调用方式不同。构造函数通常使用new操作符来调用，如果不使用new操作符，而是直接调用，就是一个普通函数，则适用普通函数规则。

### 构造函数的问题
构造函数的主要问题是：其定义的方法不能共用Function实例。
为了解决这个问题，可以把方法定义在构造函数外部，但这又会搞乱全局作用域，同时使自定义类型引用的代码不能聚集在一起。

## 原型模式

```js
function Student() {}

Student.prototype.name = 'Nicholas'
Student.prototype.age = 29
Student.prototype.job = 'Software Engineer'
Student.prototype.sayName = function () {
    console.log(this.name)
}

let person5 = new Student()
let person6 = new Student()

person5.sayName()
```

## 对象迭代

* Object.values(object)，返回对象值的数组。
* Object.entries(object)，返回对象键值对数组。