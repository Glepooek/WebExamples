通过Object构造函数和对象字面量可以方便的创建对象。但这些方式也有明显不足：创建具
有同样属性和方法的多个对象需要重复编写很多代码。

## 概述
ES6中的类是封装构造函数+原型继承的语法糖。

## 工厂模式
能解决创建多个相似对象的问题，但`没有解决对象标识的问题（即新创建的对象是什么类型）`。

```js
function createPerson(name, age, job) {
    var o = new Object()
    o.name = name
    o.age = age
    o.job = job
    o.sayName = function () {
        console.log(this.name)
    }

    return o
}

let person1 = createPerson('Nicholas', 29, 'Software Engineer')
let person2 = createPerson('Greg', 27, 'Doctor')

person1.sayName()
```

## 构造函数模式
构造函数用于创建特定类型的对象。
构造函数可以是原生构造函数，如Object、Array等。也可以是自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。

```js
/*
* 构造函数创建对象
*/
function Person(name, age, job) {
    this.name = name
    this.age = age
    this.job = job
    this.sayName = function () {
        console.log(this.name)
    }
}

let person3 = new Person('Nicholas', 29, 'Software Engineer')
let person4 = new Person('Greg', 27, 'Doctor')

person3.sayName()
```

* 按照惯例，构造函数名称的首字母大写，非构造函数名称的首字母小写。
* 构造函数创建对象时，要用`new`操作符。对象属性和方法定义在构造函数内部，即构造函数内部定义的属性和方法是实例属性和方法。
* 构造函数创建对象时，`this`指向新创建的对象。

赋值给变量的函数表达式也可以表示构造函数。

```js
/*
* 函数表达式也可以表示构造函数
*/
let Person = function(name, age, job){
    this.name = name
    this.age = age
    this.job = job
    this.sayName = function () {
        console.log(this.name)
    }
}

let person3 = new Person('Nicholas', 29, 'Software Engineer')
let person4 = new Person('Greg', 27, 'Doctor')
person3.sayName()
```

### 构造函数也是函数
构造函数与普通函数的唯一区别就是它的调用方式不同。构造函数通常使用new操作符来调用，如果不使用new操作符，而是直接调用，就是一个普通函数，则适用普通函数规则。

### 构造函数的问题
构造函数的主要问题是：其定义的方法不能共用Function实例。
为了解决这个问题，可以把方法定义在构造函数外部，但这又会搞乱全局作用域，同时使自定义类型引用的代码不能聚集在一起。

## 原型模式
每个函数都会创建一个`prototype`属性，这个属性是一个对象，包含应该由特定引用类型的实例
共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处
是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以
直接赋值给它们的原型。

```js
function Student() {}
// let Student = function () {} // 函数表达式也可以表示构造函数

Student.prototype.name = 'Nicholas'
Student.prototype.age = 29
Student.prototype.job = 'Software Engineer'
Student.prototype.sayName = function () {
    console.log(this.name)
}

let student1 = new Student()
let student2 = new Student()

student1.sayName()
```

### 理解原型
构造函数原型：自定义构造函数时，会为构造函数创建一个`prototype`属性（指向原型对象）。原型对象自动获得一个`constructor`属性，这个属性指向与之关联的构造函数。
构造函数创建的每个对象实例：都包含一个`__proto__`属性，指向构造函数的`prototype`属性。

实例与构造函数原型之间有直接的联系，实例与构造函数之间没有直接联系。

* 通过isPrototypeOf()方法判断实例与构造函数原型之间是否有直接联系，如：

```js
console.log(Student.prototype.isPrototypeOf(student1)) // true
```

* Object.getPrototypeOf(object)，返回对象的原型，如：

```js
console.log(Object.getPrototypeOf(student1))
console.log(Object.getPrototypeOf(student1) === Student.prototype) // true
```

* Object.setPrototypeOf(object, prototype)，修改对象原型，向实例的私有特性[[Prototype]]写入一个新值，如：

```js
Object.setPrototypeOf(student1, {
    numLegs: 2
})
```

* Object.create(prototype)，创建一个新对象，参数为对象原型，返回新对象，如：

```js
let biped = {
    numLegs: 2
};
let person = Object.create(biped);

person.name = 'Matt';
console.log(person.name); // Matt
console.log(person.numLegs); // 2
console.log(Object.getPrototypeOf(person) === biped); // true
```

### 原型层级


### 原型和in操作符


### 属性枚举顺序



## 对象迭代

* Object.values(object)，返回对象值的数组。
* Object.entries(object)，返回对象键值对数组。