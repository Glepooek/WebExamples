<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>图片懒加载示例</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
      }

      h1 {
        text-align: center;
        color: #333;
      }

      .intro {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 30px;
      }

      .image-container {
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        margin-bottom: 30px;
        min-height: 300px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .lazy-image {
        width: 100%;
        height: 300px;
        object-fit: cover;
        border-radius: 8px;
      }

      .placeholder {
        width: 100%;
        height: 300px;
        background-color: #eee;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #999;
        font-size: 18px;
        border-radius: 8px;
      }

      .loading {
        width: 50px;
        height: 50px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .spacer {
        height: 100px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Intersection Observer 图片懒加载示例</h1>

      <div class="intro">
        <p>这个示例演示了如何使用 Intersection Observer API 实现图片懒加载。</p>
        <p>页面中包含多个图片容器，但只有当图片进入视口时才会加载实际图片。</p>
        <p>向下滚动查看效果。</p>
      </div>

      <!-- 图片容器 1 -->
      <div class="image-container">
        <img class="lazy-image" data-src="https://picsum.photos/800/300?random=1" alt="示例图片 1" />
      </div>

      <!-- 间隔区域 -->
      <div class="spacer"></div>
      <div class="spacer"></div>
      <div class="spacer"></div>

      <!-- 图片容器 2 -->
      <div class="image-container">
        <img class="lazy-image" data-src="https://picsum.photos/800/300?random=2" alt="示例图片 2" />
      </div>

      <!-- 间隔区域 -->
      <div class="spacer"></div>
      <div class="spacer"></div>
      <div class="spacer"></div>

      <!-- 图片容器 3 -->
      <div class="image-container">
        <img class="lazy-image" data-src="https://picsum.photos/800/300?random=3" alt="示例图片 3" />
      </div>

      <!-- 间隔区域 -->
      <div class="spacer"></div>
      <div class="spacer"></div>
      <div class="spacer"></div>

      <!-- 图片容器 4 -->
      <div class="image-container">
        <img class="lazy-image" data-src="https://picsum.photos/800/300?random=4" alt="示例图片 4" />
      </div>

      <!-- 间隔区域 -->
      <div class="spacer"></div>
      <div class="spacer"></div>
      <div class="spacer"></div>

      <!-- 图片容器 5 -->
      <div class="image-container">
        <img class="lazy-image" data-src="https://picsum.photos/800/300?random=5" alt="示例图片 5" />
      </div>
    </div>

    <script>
      // IntersectionObserver API通常用于：图片懒加载、无限滚动加载内容、元素进入/离开视口时触发动画等场景。
      // 创建 Intersection Observer 实例
      const imageObserver = new IntersectionObserver(
        (entries, observer) => {
          // 遍历所有观察的条目，这里是图片元素
          entries.forEach(entry => {
            // 如果元素进入视口
            if (entry.isIntersecting) {
              // 获取目标图片元素
              const img = entry.target

              // 直接设置img.src的问题：
              // 1. 用户会看到图片逐步加载的过程，可能产生闪烁
              // 2. 无法显示加载状态，用户体验不好
              // 3. 如果图片加载失败，无法优雅处理
              // 4. 无法在图片加载完成前显示占位符

              // 显示加载指示器
              const container = img.parentNode
              // 用加载指示器替换掉图片元素
              container.innerHTML = '<div class="loading"></div>'
              // container.appendChild(img)

              // 创建新的图片元素来加载图片（预加载）
              const newImg = new Image()

              // 图片加载完成后的处理
              newImg.onload = function () {
                // 这里设置img.src不会重新加载图片，因为浏览器会从缓存中获取
                // 这样可以实现平滑的显示效果，避免闪烁
                img.src = img.dataset.src
                img.classList.remove('lazy-image')

                // 移除加载指示器并显示图片
                container.innerHTML = ''
                container.appendChild(img)
              }

              // 图片加载失败的处理
              newImg.onerror = function () {
                // 如果直接设置img.src，加载失败时用户只会看到破损的图片图标
                // 使用这种方式可以显示友好的错误信息
                container.innerHTML = '<div class="placeholder">图片加载失败</div>'
              }

              // 开始加载图片
              newImg.src = img.dataset.src

              // 停止观察已加载的图片
              observer.unobserve(img)
            }
          })
        },
        {
          // 配置选项
          //root: null, // 父元素、祖先元素或视口，null表示使用视口作为容器
          //rootMargin: '50px 0px', // 在root的基础上要扩散或收缩多少。提前50px触发加载
          threshold: 0.5, // 交叉的阈值，范围0-1，0表示只要有一部分可见就触发
        }
      )

      // 获取所有需要懒加载的图片
      const lazyImages = document.querySelectorAll('.lazy-image')

      // 开始观察每张图片
      lazyImages.forEach(img => {
        // 初始状态显示占位符
        const placeholder = document.createElement('div')
        placeholder.className = 'placeholder'
        // placeholder.textContent = '图片待加载'
        // 与 innerHTML 和 innerText 的区别：
        // innerHTML：设置或获取 HTML 内容，会解析 HTML 标签
        // textContent：设置或获取纯文本内容，忽略 HTML 标签，是 W3C 标准
        // innerText：设置或获取文本内容，但会考虑 CSS 样式（例如隐藏元素的文本不会返回）

        // 将图片容器中的img替换成占位符
        img.parentNode.replaceChild(placeholder, img)
        // 将img添加到占位符中
        placeholder.appendChild(img)

        imageObserver.observe(img)
      })
    </script>
  </body>
</html>
